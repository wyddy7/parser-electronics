<!-- 5d062481-83db-48df-807b-dcf712fbf777 83ceb09f-7baf-4771-99e2-c6f6df32033f -->
# План унификации и реализации парсеров

## Цель

Унифицировать код парсеров, устранить дублирование и реализовать 6 недостающих парсеров (chipdip, keysight, mprofit, pribor_x, zenit_electro, flukeshop) с применением современных практик.

## Фаза 1: Универсальные функции в базовом классе

### 1.1. Универсальное извлечение цены

**Файл:** `src/parsers/base_async_parser.py`

Добавить метод `_extract_price_value_universal()` который обрабатывает:

- Пробелы как разделители тысяч (`5 530 руб.`)
- Неразрывные пробелы (`&nbsp;`, `&#160;`, `\xa0`)
- Диапазоны цен (берет первую: `45 144 — 40 629 ₽`)
- Разные форматы валют (`₽`, `руб.`, `р.`)
- Форматы с НДС (`23500 ₽ (с НДС)`)

**Практики:**

- Использовать `re.sub()` для нормализации
- Обрабатывать множественные точки/запятые
- Возвращать `Optional[float]` для type safety

### 1.2. Определение статусов цены

**Файл:** `src/parsers/base_async_parser.py`

Добавить метод `_detect_price_status()` который:

- Определяет "по запросу" (-2.0): `['по запросу', 'уточняйте', 'запросить', 'уточнить', 'запрос']`
- Определяет "снят" (-1.0): `['снят', 'прекращена поставка', 'не производится']`
- Возвращает `None` если статус не определен (пробуем извлечь цену)

**Практики:**

- Case-insensitive поиск
- Проверка в тексте элемента и его родителях

### 1.3. Универсальная нормализация запроса

**Файл:** `src/parsers/base_async_parser.py`

Добавить метод `_normalize_search_query()` с базовой реализацией:

- Убирает лишние пробелы
- Переопределяется в подклассах для специфичных случаев

**Специфичные случаи:**

- `flukeshop`: убрать запятые и слова после запятой
- `electronpribor`, `pribor_x`, `zenit_electro`: пробелы → `+`
- Остальные: `urllib.parse.quote()`

### 1.4. Универсальная проверка артикулов

**Файл:** `src/parsers/base_async_parser.py`

Вынести логику `_is_name_match()` из `electronpribor_async_parser.py` в базовый класс:

- Извлечение артикулов по паттерну: `r'^([А-ЯA-ZЁ]+(?:[0-9]+)?[-/][0-9]+(?:[/][0-9]+)?)'`
- Нормализация (lowercase, убрать пробелы/дефисы, заменить латинскую A на кириллическую А)
- Точное совпадение базового артикула
- Проверка модификаций (если есть в оригинале)

**Практики:**

- Переопределение в подклассах для специфичных случаев (например, prist с гибкой проверкой URL)

## Фаза 2: Рефакторинг существующих парсеров

### 2.1. ElectronpriborAsyncParser

**Файл:** `src/parsers/electronpribor_async_parser.py`

Изменения:

- Заменить `_extract_price_value()` на `_extract_price_value_universal()`
- Использовать `_detect_price_status()` для определения статусов
- Убрать дублирование логики извлечения цены

### 2.2. PristAsyncParser

**Файл:** `src/parsers/prist_async_parser.py`

Изменения:

- Заменить `_extract_price_value()` на `_extract_price_value_universal()`
- Использовать `_is_name_match()` из базового класса (или переопределить для гибкой проверки URL)
- Улучшить проверку модификаций: более строгая, но с учетом URL

## Фаза 3: Реализация новых парсеров

### 3.1. ChipDipAsyncParser

**Файл:** `src/parsers/chipdip_async_parser.py`

Особенности:

- URL: `https://www.chipdip.ru/search?searchtext={query}` (с `urllib.parse.quote()`)
- Селектор: `table.itemlist#itemlist > tr.with-hover`
- Цена: `.price.price-main` или `#price_{id}` (обрабатывать `&#160;`)
- Фильтрация: строгая проверка артикулов (поиск находит много нерелевантных)

**Практики:**

- Использовать `select_one()` для первого элемента
- Обрабатывать `&#160;` через универсальную функцию

### 3.2. KeysightTechnologiesAsyncParser

**Файл:** `src/parsers/keysight_technologies_async_parser.py`

Особенности:

- URL: `https://keysight-technologies.ru/index.php?route=product/search&search={query}&description=true` (обязательный параметр)
- Селектор: `.products-block.row > .product-layout.product-grid`
- Цена: извлекать из `.option__item[data-price]` (атрибут `data-price`)
- Игнорировать базовую цену `.product-thumb__price.price` (обычно 81 ₽)
- Если несколько опций — брать первую с ценой > 1000

**Практики:**

- Использовать `select()` для опций
- Фильтровать опции по значению `data-price`
- Использовать CSS селекторы с атрибутами: `.option__item[data-price]`

### 3.3. MProfitAsyncParser

**Файл:** `src/parsers/mprofit_async_parser.py`

Особенности:

- URL: `https://mprofit.ru/catalog/?q={query}&s=Найти&type=catalog` (с `urllib.parse.quote()`)
- Селектор: `.catalog.list.search.js_wrapper_items > .list_item_wrapp.item_wrap.item`
- Цена: `.price_value` (пробелы как разделители тысяч)
- Статус "по запросу": текст `Цена по запросу` в `.price`

**Практики:**

- Использовать `_detect_price_status()` для определения статуса
- Использовать универсальную функцию извлечения цены

### 3.4. PriborXAsyncParser

**Файл:** `src/parsers/pribor_x_async_parser.py`

Особенности:

- URL: `https://www.pribor-x.ru/catalog/?q={query}&how=r` (пробелы → `+`)
- Селектор: `.catalog.list.search.js_wrapper_items > .list_item_wrapp.item_wrap.item`
- Цена: `.price .price_value` (обрабатывать `&nbsp;`)
- Статус "по запросу": `.to-order span` с текстом "Цена по запросу"

**Практики:**

- Переопределить `_normalize_search_query()` для замены пробелов на `+`
- Использовать универсальную функцию извлечения цены (обрабатывает `&nbsp;`)

### 3.5. ZenitElectroAsyncParser

**Файл:** `src/parsers/zenit_electro_async_parser.py`

Особенности:

- Двухэтапный парсинг (как prist): поиск → страница товара
- URL поиска: `https://www.zenit-electro.ru/component/finder/search.html?q={query}&Search=` (пробелы → `+`)
- Селектор результатов: `ul#search-result-list > li`
- Ссылка: `h4.result-title a[href]`
- Страница товара: `span#block_price` → извлечь число из `23500 ₽ (с НДС)`

**Практики:**

- Использовать паттерн из `PristAsyncParser` (2 запроса)
- Переопределить `_normalize_search_query()` для замены пробелов на `+`
- Использовать универсальную функцию извлечения цены (обрабатывает формат с НДС)

### 3.6. FlukeShopAsyncParser

**Файл:** `src/parsers/flukeshop_async_parser.py`

Особенности:

- Нормализация запроса: убрать запятые и слова после запятой (`"Fluke TiX501, тепловизор"` → `"Fluke TiX501"`)
- URL: `https://flukeshop.ru/search?search={query}` (с `urllib.parse.quote()`)
- Селектор: `div#products.product-grid > div.products-block > div.row.products-row > div.product-col`
- Цена: `div.price span.price-new` (формат: `1 058 992 р.`)
- Статус "по запросу": текст `По запросу`

**Практики:**

- Переопределить `_normalize_search_query()` для удаления запятых
- Использовать универсальную функцию извлечения цены (обрабатывает "р." как валюту)

## Фаза 4: Регистрация парсеров

### 4.1. Обновление factory.py

**Файл:** `src/parsers/factory.py`

Добавить автоматическую регистрацию новых парсеров в `_auto_register()`:

- `ChipDipAsyncParser`
- `KeysightTechnologiesAsyncParser`
- `MProfitAsyncParser`
- `PriborXAsyncParser`
- `ZenitElectroAsyncParser`
- `FlukeShopAsyncParser`

## Фаза 5: Тестирование и валидация

### 5.1. Проверка каждого парсера

Для каждого парсера проверить:

- Корректное извлечение цены
- Определение статусов ("по запросу", "снят")
- Совпадение артикулов
- Обработка нерелевантных результатов (chipdip)

### 5.2. Проверка универсальных функций

- Обработка всех форматов цен
- Обработка неразрывных пробелов
- Обработка диапазонов цен
- Определение статусов

## Современные практики (из Context7)

### HTTPX

- Использовать `httpx.AsyncClient` с connection pooling (уже реализовано)
- Использовать `httpx.Limits` для управления пулом соединений
- Использовать `httpx.Timeout` для таймаутов
- Context manager (`async with`) для автоматического закрытия

### BeautifulSoup

- Использовать `lxml` parser (быстрее чем `html.parser`)
- Использовать CSS селекторы через `select()` и `select_one()`
- Использовать `get_text(strip=True)` для извлечения текста
- Использовать `unwrap()` для удаления тегов без потери содержимого

### Asyncio

- Использовать `asyncio.Semaphore` для rate limiting (уже реализовано)
- Использовать `asyncio.gather()` для параллельных запросов
- Правильное управление ресурсами через context managers

## Критерии успеха

1. Все 8 парсеров реализованы и работают
2. Универсальные функции используются везде (нет дублирования)
3. Все форматы цен обрабатываются корректно
4. Все статусы определяются правильно
5. Код соответствует современным практикам Python/async
6. Производительность сохранена или улучшена

### To-dos

- [ ] Добавить _extract_price_value_universal() в base_async_parser.py с обработкой всех форматов цен (пробелы, &nbsp;, диапазоны, валюты)
- [ ] Добавить _detect_price_status() в base_async_parser.py для определения статусов (по запросу, снят)
- [ ] Добавить _normalize_search_query() в base_async_parser.py с базовой реализацией и возможностью переопределения
- [ ] Вынести _is_name_match() из electronpribor_async_parser.py в base_async_parser.py как универсальную функцию
- [ ] Рефакторинг ElectronpriborAsyncParser: использовать универсальные функции вместо дублирования
- [ ] Рефакторинг PristAsyncParser: использовать универсальные функции, улучшить проверку модификаций
- [ ] Реализовать ChipDipAsyncParser с фильтрацией нерелевантных результатов
- [ ] Реализовать KeysightTechnologiesAsyncParser с извлечением цены из опций (data-price)
- [ ] Реализовать MProfitAsyncParser с обработкой статуса по запросу
- [ ] Реализовать PriborXAsyncParser с обработкой &nbsp; и нормализацией запроса (пробелы → +)
- [ ] Реализовать ZenitElectroAsyncParser с двухэтапным парсингом (поиск → страница товара)
- [ ] Реализовать FlukeShopAsyncParser с нормализацией запроса (убрать запятые)
- [ ] Обновить factory.py для автоматической регистрации всех новых парсеров